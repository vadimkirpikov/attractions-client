/**
 * Generated by orval v7.8.0 ðŸº
 * Do not edit manually.
 * TouristServer
 * OpenAPI spec version: 1.0
 */
import type {
  FilterDto,
  GetV1PlacesPhotosOfPlacePlaceIdParams,
  PostV1PlacesGetFilteredParams
} from '.././models';


export type postV1PlacesGetFilteredResponse200 = {
  data: void
  status: 200
}
    
export type postV1PlacesGetFilteredResponseComposite = postV1PlacesGetFilteredResponse200;
    
export type postV1PlacesGetFilteredResponse = postV1PlacesGetFilteredResponseComposite & {
  headers: Headers;
}

export const getPostV1PlacesGetFilteredUrl = (params?: PostV1PlacesGetFilteredParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:8080/v1/places/get-filtered?${stringifiedParams}` : `http://localhost:8080/v1/places/get-filtered`
}

export const postV1PlacesGetFiltered = async (filterDto: FilterDto,
    params?: PostV1PlacesGetFilteredParams, options?: RequestInit): Promise<postV1PlacesGetFilteredResponse> => {
  
  const res = await fetch(getPostV1PlacesGetFilteredUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      filterDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postV1PlacesGetFilteredResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postV1PlacesGetFilteredResponse
}


export type getV1PlacesPhotosOfPlacePlaceIdResponse200 = {
  data: void
  status: 200
}
    
export type getV1PlacesPhotosOfPlacePlaceIdResponseComposite = getV1PlacesPhotosOfPlacePlaceIdResponse200;
    
export type getV1PlacesPhotosOfPlacePlaceIdResponse = getV1PlacesPhotosOfPlacePlaceIdResponseComposite & {
  headers: Headers;
}

export const getGetV1PlacesPhotosOfPlacePlaceIdUrl = (placeId: string,
    params?: GetV1PlacesPhotosOfPlacePlaceIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:8080/v1/places/photosOfPlace/${placeId}?${stringifiedParams}` : `http://localhost:8080/v1/places/photosOfPlace/${placeId}`
}

export const getV1PlacesPhotosOfPlacePlaceId = async (placeId: string,
    params?: GetV1PlacesPhotosOfPlacePlaceIdParams, options?: RequestInit): Promise<getV1PlacesPhotosOfPlacePlaceIdResponse> => {
  
  const res = await fetch(getGetV1PlacesPhotosOfPlacePlaceIdUrl(placeId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getV1PlacesPhotosOfPlacePlaceIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getV1PlacesPhotosOfPlacePlaceIdResponse
}


